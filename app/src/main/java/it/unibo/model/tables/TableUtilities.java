package it.unibo.model.tables;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.logging.Level;
import java.util.logging.Logger;

import it.unibo.common.Constants;

/**
 * utility class that generates methods commonly used by table classes.
 */
public final class TableUtilities {

    private TableUtilities() {
    }

    /**
     * Logs an error generated by an SQL operation.
     * 
     * @param obj the class that generated the error
     * @param e   {@link SQLException} generated by the class
     */
    public static void logSQLException(final Object obj, final SQLException e) {
        Logger.getLogger(obj.getClass().getName()).log(Level.SEVERE, Constants.STATEMENT_CREATION_ERROR, e);
    }

    /**
     * Retrieves the next number for a sighting or extraction in a given expedition.
     * 
     * @param tableName      the name of the table in the database
     * @param expeditionCode the code of the expedition
     * @param connection     the connection to the database
     * @param obj            the class that called this method
     * @return the next number if everything went fine, -1 otherwise
     */
    public static int getNextNumber(final String tableName, final String expeditionCode, final Connection connection,
            final Object obj) {
        final String query1 = "SELECT MAX(Numero) FROM " + Constants.SIGHTINGS + Constants.WHERE + "CodiceSpedizione"
                + Constants.QUESTION_MARK;
        final String query2 = "SELECT MAX(Numero) FROM " + Constants.EXTRACTIONS + Constants.WHERE + "CodiceSpedizione"
                + Constants.QUESTION_MARK;
        if (Constants.SIGHTINGS.equals(tableName)) {
            try (PreparedStatement statement = connection.prepareStatement(query1)) {
                statement.setString(Constants.SINGLE_QUERY_VALUE_INDEX, expeditionCode);
                final ResultSet resultSet = statement.executeQuery();
                return resultSet.next() ? resultSet.getInt(Constants.SINGLE_QUERY_VALUE_INDEX) + 1 : 1;
            } catch (final SQLException e) {
                TableUtilities.logSQLException(obj, e);
                return -1;
            }
        } else {
            try (PreparedStatement statement = connection.prepareStatement(query2)) {
                statement.setString(Constants.SINGLE_QUERY_VALUE_INDEX, expeditionCode);
                final ResultSet resultSet = statement.executeQuery();
                return resultSet.next() ? resultSet.getInt(Constants.SINGLE_QUERY_VALUE_INDEX) + 1 : 1;
            } catch (final SQLException e) {
                TableUtilities.logSQLException(obj, e);
                return -1;
            }
        }
    }

    /**
     * Executes a standard delete query operation.
     * 
     * @param query      the query
     * @param primaryKey the primary key
     * @param connection the connection to the database
     * @param obj        the class that called this method
     * @return true if the operation was successful, false otherwise
     */
    public static boolean deleteOperation(final String query, final String primaryKey, final Connection connection,
            final Object obj) {
        try (PreparedStatement statement = connection.prepareStatement(query)) {
            statement.setString(Constants.SINGLE_QUERY_VALUE_INDEX, primaryKey);
            return statement.executeUpdate() > 0;
        } catch (final SQLException e) {
            TableUtilities.logSQLException(obj, e);
            return false;
        }
    }
}
